## TCP
  - #### `신뢰성 있는` 데이터 전송을 지원하는 프로토콜
  - #### <img src="https://user-images.githubusercontent.com/35948339/139862485-c3bb6cdf-b95e-412a-b527-b23c3e8309c7.png" width=600> <br><br> 연결을 시작할 때는 `3-Way handshake`를 통해 연결을 수립한다.
    - #### SYN : Synchronize Sequence Number <br> ACK : Acknowledgement
    - #### 1️⃣ 클라이언트는 서버에 접속을 요청하기 위해 SYN 패킷을 보낸다.
    - #### 2️⃣ 서버는 `SYN 패킷`을 받고 클라이언트에게 요청을 수락하는 `ACK 패킷`과 포트를 열어달라는 `SYN 패킷`을 다시 보낸다.
    - #### 3️⃣ 클라이언트는 `SYN 패킷`을 받고 서버에 요청을 수락했다는 `ACK 패킷`을 보내며 연결이 수립된다.
    ---------
    - #### TCP Header에는 `Control Bit (플래그 비트, 6 bit)`가 존재하며, 각각의 bit는 `URG / ACK / PSH / RST / SYN / FIN` 이다. <br><br> 해당 bit가 1이면 패킷에는 어떠한 `Control Bit`가 있는지 알 수 있다.
    ---------
    - #### ❓ 1️⃣ 에서 `SYN 패킷`을 보낼 때, `Sequence Number`에는 `랜덤한 숫자`가 담겨진다. <br><br> 그 이유는, 연결을 수립 할 때 `한정 범위 내에 있는 포트`를 사용하고 시간이 지나면 `재사용 할 가능성이 크다.` <br><br> 만약 `순차적인 Sequence Number`를 담는다면 `이전 Connection의 패킷`으로 인식할 가능성이 있기 때문에 `랜덤한 숫자`를 담는다.
  -------------
  - #### <img src="https://user-images.githubusercontent.com/35948339/139862643-14439ed5-97bd-438c-9b52-20f52e3f4ab7.png" width=600> <br><br> 연결을 종료할 때는 `4-Way handshake`를 통해 연결을 종료한다.
    - #### 1️⃣ 클라이언트가 연결을 종료하겠다는 `FIN 패킷`을 전송한다.
    - #### 2️⃣ 서버는 클라이언트의 `FIN 요청`을 받고 확인했다는 `ACK 패킷`을 보낸다. <br><br> 연결된 통신이 끝날 때까지 기다리며 서버는 `해당 포트에 연결되어 있는 어플리케이션`에게 `Close()`를 요청한다.
    - #### 3️⃣ `Close()` 요청을 받은 어플리케이션은 연결을 종료하고 `FIN 패킷`을 클라이언트에게 전송한다.
    - #### 4️⃣ 클라이언트는 `FIN 패킷`에 대한 확인 응답으로 `ACK 패킷`을 전송하고 <br> `아직 서버로부터 받지 못한 데이터`가 있을 것을 대비해 `대기(TIME_WAIT)`를 거친다.
    - #### 5️⃣ 서버는 `ACK 패킷`을 받으면 연결을 `closed`한다.
    --------
    ``` 
     클라이언트에서 `FIN 패킷` 전송 후 `ACK 패킷`를 기다리는 `FIN_WAIT1`
     서버의 `ACK 패킷`을 받은 후 서버의 `FIN 패킷`을 기다리는 `FIN_WAIT2`
    ```
    - #### 🔼 위 두 가지 경우에는  일정 시간 후, `Time Out`이 되면 `스스로 연결을 종료한다.`
    - #### 🟥 그러나 `CLOSE_WAIT`은 `어플리케이션에서 close()`를 하지 않으면 계속 `CLOSE_WAIT` 상태로 기다린다. <br><br> 이런 상태가 많아지면 `Hang`이 걸려 더 이상 연결을 못하는 경우가 발생한다.
  -----------
  - ### TCP 특징
    - #### 연결형 서비스로 `가상 회선 방식`을 제공한다.
    - #### `데이터 전송 순서를 보장`한다.
    - #### 흐름 제어 및 혼잡 제어가 가능하다.
    - #### 높은 신뢰성을 보장한다.
    - #### UDP 보다 속도가 느리다.
    - #### Streaming 서비스에 불리하다. `(손실된 경우 재전송 요청을 하기 때문에)`
    - #### 스트림 전송으로 `전송하는 데이터 크기가 무제한`이다.
----------------
## UDP
  - #### 비연결성 및 연속성이 중요한 데이터 전송을 지원하는 프로토콜
  - ### UDP의 특징
    - #### 비연결형 서비스로 `데이터그램 방식`을 제공한다.
    - #### TCP처럼 handshake와 같은 절차 없이 바로 연결한다.
    - #### UDP Header의 `Checksum 필드`를 통해 `최소한의 오류`만 검출한다.
    - #### TCP보다 신뢰성이 낮지만 속도는 빠르다.
    - #### Streaming 서비스에 적합하다.
    - #### `데이터그램(메세지)` 단위로 전송되며 `크기는 65535 바이트`로 초과하면 잘라서 보낸다.
---------------
- ## 가상 회선 방식 이란? <br><br> <img src="https://user-images.githubusercontent.com/35948339/139877716-2395ade8-7781-4e54-a50e-1f114347e78b.png" width=600>
  - #### 처음 패킷으로 최적의 경로를 찾고, 그 경로를 통해 패킷을 나누어서 고속으로 전송한다.
  - #### 모든 패킷을 전송하면 가상 회선이 해제되고 패킷들은 전송된 순서대로 도착한다.
--------------
- ## 데이터 그램 방식 이란? <br><br> <img src="https://user-images.githubusercontent.com/35948339/139877540-24000809-8d30-4251-bcbd-5066adf8f340.png" width=600>
  - #### 각 패킷을 정해진 경로 없이 독립적으로 목적지에 도착한다.
  - #### 짧은 메시지를 전송할 때 사용되고 재정렬 기능이 필요하다.
